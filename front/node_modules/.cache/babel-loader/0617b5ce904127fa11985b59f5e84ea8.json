{"ast":null,"code":"import merge from '../merge';\nimport { styleFunctionMapping as defaultStyleFunctionMapping } from '../getThemeValue';\nimport { handleBreakpoints, createEmptyBreakpointObject, removeUnusedBreakpoints } from '../breakpoints';\n\nfunction objectsHaveSameKeys() {\n  for (var _len = arguments.length, objects = new Array(_len), _key = 0; _key < _len; _key++) {\n    objects[_key] = arguments[_key];\n  }\n\n  const allKeys = objects.reduce((keys, object) => keys.concat(Object.keys(object)), []);\n  const union = new Set(allKeys);\n  return objects.every(object => union.size === Object.keys(object).length);\n}\n\nfunction callIfFn(maybeFn, arg) {\n  return typeof maybeFn === 'function' ? maybeFn(arg) : maybeFn;\n} // eslint-disable-next-line @typescript-eslint/naming-convention\n\n\nexport function unstable_createStyleFunctionSx() {\n  let styleFunctionMapping = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : defaultStyleFunctionMapping;\n  const propToStyleFunction = Object.keys(styleFunctionMapping).reduce((acc, styleFnName) => {\n    styleFunctionMapping[styleFnName].filterProps.forEach(propName => {\n      acc[propName] = styleFunctionMapping[styleFnName];\n    });\n    return acc;\n  }, {});\n\n  function getThemeValue(prop, value, theme) {\n    const inputProps = {\n      [prop]: value,\n      theme\n    };\n    const styleFunction = propToStyleFunction[prop];\n    return styleFunction ? styleFunction(inputProps) : {\n      [prop]: value\n    };\n  }\n\n  function styleFunctionSx(props) {\n    const {\n      sx,\n      theme = {}\n    } = props || {};\n\n    if (!sx) {\n      return null; // emotion & styled-components will neglect null\n    }\n    /*\n     * Receive `sxInput` as object or callback\n     * and then recursively check keys & values to create media query object styles.\n     * (the result will be used in `styled`)\n     */\n\n\n    function traverse(sxInput) {\n      let sxObject = sxInput;\n\n      if (typeof sxInput === 'function') {\n        sxObject = sxInput(theme);\n      } else if (typeof sxInput !== 'object') {\n        // value\n        return sxInput;\n      }\n\n      if (!sxObject) {\n        return null;\n      }\n\n      const emptyBreakpoints = createEmptyBreakpointObject(theme.breakpoints);\n      const breakpointsKeys = Object.keys(emptyBreakpoints);\n      let css = emptyBreakpoints;\n      Object.keys(sxObject).forEach(styleKey => {\n        const value = callIfFn(sxObject[styleKey], theme);\n\n        if (value !== null && value !== undefined) {\n          if (typeof value === 'object') {\n            if (propToStyleFunction[styleKey]) {\n              css = merge(css, getThemeValue(styleKey, value, theme));\n            } else {\n              const breakpointsValues = handleBreakpoints({\n                theme\n              }, value, x => ({\n                [styleKey]: x\n              }));\n\n              if (objectsHaveSameKeys(breakpointsValues, value)) {\n                css[styleKey] = styleFunctionSx({\n                  sx: value,\n                  theme\n                });\n              } else {\n                css = merge(css, breakpointsValues);\n              }\n            }\n          } else {\n            css = merge(css, getThemeValue(styleKey, value, theme));\n          }\n        }\n      });\n      return removeUnusedBreakpoints(breakpointsKeys, css);\n    }\n\n    return Array.isArray(sx) ? sx.map(traverse) : traverse(sx);\n  }\n\n  return styleFunctionSx;\n}\nconst styleFunctionSx = unstable_createStyleFunctionSx();\nstyleFunctionSx.filterProps = ['sx'];\nexport default styleFunctionSx;","map":{"version":3,"sources":["/Users/juancarlossilva/Documents/apps/backend-test/front/node_modules/@mui/system/esm/styleFunctionSx/styleFunctionSx.js"],"names":["merge","styleFunctionMapping","defaultStyleFunctionMapping","handleBreakpoints","createEmptyBreakpointObject","removeUnusedBreakpoints","objectsHaveSameKeys","objects","allKeys","reduce","keys","object","concat","Object","union","Set","every","size","length","callIfFn","maybeFn","arg","unstable_createStyleFunctionSx","propToStyleFunction","acc","styleFnName","filterProps","forEach","propName","getThemeValue","prop","value","theme","inputProps","styleFunction","styleFunctionSx","props","sx","traverse","sxInput","sxObject","emptyBreakpoints","breakpoints","breakpointsKeys","css","styleKey","undefined","breakpointsValues","x","Array","isArray","map"],"mappings":"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","sourcesContent":["import merge from '../merge';\nimport { styleFunctionMapping as defaultStyleFunctionMapping } from '../getThemeValue';\nimport { handleBreakpoints, createEmptyBreakpointObject, removeUnusedBreakpoints } from '../breakpoints';\n\nfunction objectsHaveSameKeys(...objects) {\n  const allKeys = objects.reduce((keys, object) => keys.concat(Object.keys(object)), []);\n  const union = new Set(allKeys);\n  return objects.every(object => union.size === Object.keys(object).length);\n}\n\nfunction callIfFn(maybeFn, arg) {\n  return typeof maybeFn === 'function' ? maybeFn(arg) : maybeFn;\n} // eslint-disable-next-line @typescript-eslint/naming-convention\n\n\nexport function unstable_createStyleFunctionSx(styleFunctionMapping = defaultStyleFunctionMapping) {\n  const propToStyleFunction = Object.keys(styleFunctionMapping).reduce((acc, styleFnName) => {\n    styleFunctionMapping[styleFnName].filterProps.forEach(propName => {\n      acc[propName] = styleFunctionMapping[styleFnName];\n    });\n    return acc;\n  }, {});\n\n  function getThemeValue(prop, value, theme) {\n    const inputProps = {\n      [prop]: value,\n      theme\n    };\n    const styleFunction = propToStyleFunction[prop];\n    return styleFunction ? styleFunction(inputProps) : {\n      [prop]: value\n    };\n  }\n\n  function styleFunctionSx(props) {\n    const {\n      sx,\n      theme = {}\n    } = props || {};\n\n    if (!sx) {\n      return null; // emotion & styled-components will neglect null\n    }\n    /*\n     * Receive `sxInput` as object or callback\n     * and then recursively check keys & values to create media query object styles.\n     * (the result will be used in `styled`)\n     */\n\n\n    function traverse(sxInput) {\n      let sxObject = sxInput;\n\n      if (typeof sxInput === 'function') {\n        sxObject = sxInput(theme);\n      } else if (typeof sxInput !== 'object') {\n        // value\n        return sxInput;\n      }\n\n      if (!sxObject) {\n        return null;\n      }\n\n      const emptyBreakpoints = createEmptyBreakpointObject(theme.breakpoints);\n      const breakpointsKeys = Object.keys(emptyBreakpoints);\n      let css = emptyBreakpoints;\n      Object.keys(sxObject).forEach(styleKey => {\n        const value = callIfFn(sxObject[styleKey], theme);\n\n        if (value !== null && value !== undefined) {\n          if (typeof value === 'object') {\n            if (propToStyleFunction[styleKey]) {\n              css = merge(css, getThemeValue(styleKey, value, theme));\n            } else {\n              const breakpointsValues = handleBreakpoints({\n                theme\n              }, value, x => ({\n                [styleKey]: x\n              }));\n\n              if (objectsHaveSameKeys(breakpointsValues, value)) {\n                css[styleKey] = styleFunctionSx({\n                  sx: value,\n                  theme\n                });\n              } else {\n                css = merge(css, breakpointsValues);\n              }\n            }\n          } else {\n            css = merge(css, getThemeValue(styleKey, value, theme));\n          }\n        }\n      });\n      return removeUnusedBreakpoints(breakpointsKeys, css);\n    }\n\n    return Array.isArray(sx) ? sx.map(traverse) : traverse(sx);\n  }\n\n  return styleFunctionSx;\n}\nconst styleFunctionSx = unstable_createStyleFunctionSx();\nstyleFunctionSx.filterProps = ['sx'];\nexport default styleFunctionSx;"]},"metadata":{},"sourceType":"module"}