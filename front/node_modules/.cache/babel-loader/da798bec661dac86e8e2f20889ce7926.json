{"ast":null,"code":"import _extends from \"@babel/runtime/helpers/esm/extends\";\nimport * as React from 'react';\nimport { unstable_ownerDocument as ownerDocument, unstable_useForkRef as useForkRef } from '@mui/utils';\nimport { isFragment } from 'react-is';\nimport { useTabContext } from '../TabsUnstyled';\nimport extractEventHandlers from '../utils/extractEventHandlers';\n\nconst nextItem = (list, item) => {\n  if (!list) {\n    return null;\n  }\n\n  if (list === item) {\n    return list.firstChild;\n  }\n\n  if (item && item.nextElementSibling) {\n    return item.nextElementSibling;\n  }\n\n  return list.firstChild;\n};\n\nconst previousItem = (list, item) => {\n  if (!list) {\n    return null;\n  }\n\n  if (list === item) {\n    return list.lastChild;\n  }\n\n  if (item && item.previousElementSibling) {\n    return item.previousElementSibling;\n  }\n\n  return list.lastChild;\n};\n\nconst moveFocus = (list, currentFocus, traversalFunction) => {\n  let wrappedOnce = false;\n  let nextFocus = traversalFunction(list, currentFocus);\n\n  while (list && nextFocus) {\n    // Prevent infinite loop.\n    if (nextFocus === list.firstChild) {\n      if (wrappedOnce) {\n        return;\n      }\n\n      wrappedOnce = true;\n    } // Same logic as useAutocomplete.js\n\n\n    const nextFocusDisabled = nextFocus.disabled || nextFocus.getAttribute('aria-disabled') === 'true';\n\n    if (!nextFocus.hasAttribute('tabindex') || nextFocusDisabled) {\n      // Move to the next element.\n      nextFocus = traversalFunction(list, nextFocus);\n    } else {\n      nextFocus.focus();\n      return;\n    }\n  }\n};\n\nconst useTabsList = props => {\n  const {\n    'aria-label': ariaLabel,\n    'aria-labelledby': ariaLabelledBy,\n    children,\n    ref\n  } = props;\n  const tabsListRef = /*#__PURE__*/React.createRef();\n  const handleRef = useForkRef(tabsListRef, ref);\n  const context = useTabContext();\n\n  if (context === null) {\n    throw new Error('No TabContext provided');\n  }\n\n  const {\n    value,\n    orientation = 'horizontal',\n    direction = 'ltr'\n  } = context;\n  const isRtl = direction === 'rtl';\n\n  const handleKeyDown = event => {\n    const list = tabsListRef.current;\n    const currentFocus = ownerDocument(list).activeElement; // Keyboard navigation assumes that [role=\"tab\"] are siblings\n    // though we might warn in the future about nested, interactive elements\n    // as a a11y violation\n\n    const role = currentFocus == null ? void 0 : currentFocus.getAttribute('role');\n\n    if (role !== 'tab') {\n      return;\n    }\n\n    let previousItemKey = orientation === 'horizontal' ? 'ArrowLeft' : 'ArrowUp';\n    let nextItemKey = orientation === 'horizontal' ? 'ArrowRight' : 'ArrowDown';\n\n    if (orientation === 'horizontal' && isRtl) {\n      // swap previousItemKey with nextItemKey\n      previousItemKey = 'ArrowRight';\n      nextItemKey = 'ArrowLeft';\n    }\n\n    switch (event.key) {\n      case previousItemKey:\n        event.preventDefault();\n        moveFocus(list, currentFocus, previousItem);\n        break;\n\n      case nextItemKey:\n        event.preventDefault();\n        moveFocus(list, currentFocus, nextItem);\n        break;\n\n      case 'Home':\n        event.preventDefault();\n        moveFocus(list, null, nextItem);\n        break;\n\n      case 'End':\n        event.preventDefault();\n        moveFocus(list, null, previousItem);\n        break;\n\n      default:\n        break;\n    }\n  };\n\n  const createHandleKeyDown = otherHandlers => event => {\n    var _otherHandlers$onKeyD;\n\n    handleKeyDown(event);\n    (_otherHandlers$onKeyD = otherHandlers.onKeyDown) == null ? void 0 : _otherHandlers$onKeyD.call(otherHandlers, event);\n  };\n\n  const getRootProps = otherHandlers => {\n    const propsEventHandlers = extractEventHandlers(props);\n\n    const externalEventHandlers = _extends({}, propsEventHandlers, otherHandlers);\n\n    const ownEventHandlers = {\n      onKeyDown: createHandleKeyDown(externalEventHandlers)\n    };\n\n    const mergedEventHandlers = _extends({}, externalEventHandlers, ownEventHandlers);\n\n    return _extends({\n      'aria-label': ariaLabel,\n      'aria-labelledby': ariaLabelledBy,\n      'aria-orientation': orientation === 'vertical' ? 'vertical' : null,\n      role: 'tablist',\n      ref: handleRef\n    }, mergedEventHandlers);\n  };\n\n  const processChildren = React.useCallback(() => {\n    const valueToIndex = new Map();\n    let childIndex = 0;\n    const processedChildren = React.Children.map(children, child => {\n      if (! /*#__PURE__*/React.isValidElement(child)) {\n        return null;\n      }\n\n      if (process.env.NODE_ENV !== 'production') {\n        if (isFragment(child)) {\n          console.error([\"MUI: The Tabs component doesn't accept a Fragment as a child.\", 'Consider providing an array instead.'].join('\\n'));\n        }\n      }\n\n      const childValue = child.props.value === undefined ? childIndex : child.props.value;\n      valueToIndex.set(childValue, childIndex);\n      childIndex += 1;\n      return /*#__PURE__*/React.cloneElement(child, _extends({\n        value: childValue\n      }, childIndex === 1 && value === false && !child.props.tabIndex || value === childValue ? {\n        tabIndex: 0\n      } : {\n        tabIndex: -1\n      }));\n    });\n    return processedChildren;\n  }, [children, value]);\n  return {\n    isRtl,\n    orientation,\n    value,\n    processChildren,\n    getRootProps\n  };\n};\n\nexport default useTabsList;","map":{"version":3,"sources":["/Users/juancarlossilva/Documents/apps/backend-test/front/node_modules/@mui/base/TabsListUnstyled/useTabsList.js"],"names":["_extends","React","unstable_ownerDocument","ownerDocument","unstable_useForkRef","useForkRef","isFragment","useTabContext","extractEventHandlers","nextItem","list","item","firstChild","nextElementSibling","previousItem","lastChild","previousElementSibling","moveFocus","currentFocus","traversalFunction","wrappedOnce","nextFocus","nextFocusDisabled","disabled","getAttribute","hasAttribute","focus","useTabsList","props","ariaLabel","ariaLabelledBy","children","ref","tabsListRef","createRef","handleRef","context","Error","value","orientation","direction","isRtl","handleKeyDown","event","current","activeElement","role","previousItemKey","nextItemKey","key","preventDefault","createHandleKeyDown","otherHandlers","_otherHandlers$onKeyD","onKeyDown","call","getRootProps","propsEventHandlers","externalEventHandlers","ownEventHandlers","mergedEventHandlers","processChildren","useCallback","valueToIndex","Map","childIndex","processedChildren","Children","map","child","isValidElement","process","env","NODE_ENV","console","error","join","childValue","undefined","set","cloneElement","tabIndex"],"mappings":"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","sourcesContent":["import _extends from \"@babel/runtime/helpers/esm/extends\";\nimport * as React from 'react';\nimport { unstable_ownerDocument as ownerDocument, unstable_useForkRef as useForkRef } from '@mui/utils';\nimport { isFragment } from 'react-is';\nimport { useTabContext } from '../TabsUnstyled';\nimport extractEventHandlers from '../utils/extractEventHandlers';\n\nconst nextItem = (list, item) => {\n  if (!list) {\n    return null;\n  }\n\n  if (list === item) {\n    return list.firstChild;\n  }\n\n  if (item && item.nextElementSibling) {\n    return item.nextElementSibling;\n  }\n\n  return list.firstChild;\n};\n\nconst previousItem = (list, item) => {\n  if (!list) {\n    return null;\n  }\n\n  if (list === item) {\n    return list.lastChild;\n  }\n\n  if (item && item.previousElementSibling) {\n    return item.previousElementSibling;\n  }\n\n  return list.lastChild;\n};\n\nconst moveFocus = (list, currentFocus, traversalFunction) => {\n  let wrappedOnce = false;\n  let nextFocus = traversalFunction(list, currentFocus);\n\n  while (list && nextFocus) {\n    // Prevent infinite loop.\n    if (nextFocus === list.firstChild) {\n      if (wrappedOnce) {\n        return;\n      }\n\n      wrappedOnce = true;\n    } // Same logic as useAutocomplete.js\n\n\n    const nextFocusDisabled = nextFocus.disabled || nextFocus.getAttribute('aria-disabled') === 'true';\n\n    if (!nextFocus.hasAttribute('tabindex') || nextFocusDisabled) {\n      // Move to the next element.\n      nextFocus = traversalFunction(list, nextFocus);\n    } else {\n      nextFocus.focus();\n      return;\n    }\n  }\n};\n\nconst useTabsList = props => {\n  const {\n    'aria-label': ariaLabel,\n    'aria-labelledby': ariaLabelledBy,\n    children,\n    ref\n  } = props;\n  const tabsListRef = /*#__PURE__*/React.createRef();\n  const handleRef = useForkRef(tabsListRef, ref);\n  const context = useTabContext();\n\n  if (context === null) {\n    throw new Error('No TabContext provided');\n  }\n\n  const {\n    value,\n    orientation = 'horizontal',\n    direction = 'ltr'\n  } = context;\n  const isRtl = direction === 'rtl';\n\n  const handleKeyDown = event => {\n    const list = tabsListRef.current;\n    const currentFocus = ownerDocument(list).activeElement; // Keyboard navigation assumes that [role=\"tab\"] are siblings\n    // though we might warn in the future about nested, interactive elements\n    // as a a11y violation\n\n    const role = currentFocus == null ? void 0 : currentFocus.getAttribute('role');\n\n    if (role !== 'tab') {\n      return;\n    }\n\n    let previousItemKey = orientation === 'horizontal' ? 'ArrowLeft' : 'ArrowUp';\n    let nextItemKey = orientation === 'horizontal' ? 'ArrowRight' : 'ArrowDown';\n\n    if (orientation === 'horizontal' && isRtl) {\n      // swap previousItemKey with nextItemKey\n      previousItemKey = 'ArrowRight';\n      nextItemKey = 'ArrowLeft';\n    }\n\n    switch (event.key) {\n      case previousItemKey:\n        event.preventDefault();\n        moveFocus(list, currentFocus, previousItem);\n        break;\n\n      case nextItemKey:\n        event.preventDefault();\n        moveFocus(list, currentFocus, nextItem);\n        break;\n\n      case 'Home':\n        event.preventDefault();\n        moveFocus(list, null, nextItem);\n        break;\n\n      case 'End':\n        event.preventDefault();\n        moveFocus(list, null, previousItem);\n        break;\n\n      default:\n        break;\n    }\n  };\n\n  const createHandleKeyDown = otherHandlers => event => {\n    var _otherHandlers$onKeyD;\n\n    handleKeyDown(event);\n    (_otherHandlers$onKeyD = otherHandlers.onKeyDown) == null ? void 0 : _otherHandlers$onKeyD.call(otherHandlers, event);\n  };\n\n  const getRootProps = otherHandlers => {\n    const propsEventHandlers = extractEventHandlers(props);\n\n    const externalEventHandlers = _extends({}, propsEventHandlers, otherHandlers);\n\n    const ownEventHandlers = {\n      onKeyDown: createHandleKeyDown(externalEventHandlers)\n    };\n\n    const mergedEventHandlers = _extends({}, externalEventHandlers, ownEventHandlers);\n\n    return _extends({\n      'aria-label': ariaLabel,\n      'aria-labelledby': ariaLabelledBy,\n      'aria-orientation': orientation === 'vertical' ? 'vertical' : null,\n      role: 'tablist',\n      ref: handleRef\n    }, mergedEventHandlers);\n  };\n\n  const processChildren = React.useCallback(() => {\n    const valueToIndex = new Map();\n    let childIndex = 0;\n    const processedChildren = React.Children.map(children, child => {\n      if (! /*#__PURE__*/React.isValidElement(child)) {\n        return null;\n      }\n\n      if (process.env.NODE_ENV !== 'production') {\n        if (isFragment(child)) {\n          console.error([\"MUI: The Tabs component doesn't accept a Fragment as a child.\", 'Consider providing an array instead.'].join('\\n'));\n        }\n      }\n\n      const childValue = child.props.value === undefined ? childIndex : child.props.value;\n      valueToIndex.set(childValue, childIndex);\n      childIndex += 1;\n      return /*#__PURE__*/React.cloneElement(child, _extends({\n        value: childValue\n      }, childIndex === 1 && value === false && !child.props.tabIndex || value === childValue ? {\n        tabIndex: 0\n      } : {\n        tabIndex: -1\n      }));\n    });\n    return processedChildren;\n  }, [children, value]);\n  return {\n    isRtl,\n    orientation,\n    value,\n    processChildren,\n    getRootProps\n  };\n};\n\nexport default useTabsList;"]},"metadata":{},"sourceType":"module"}